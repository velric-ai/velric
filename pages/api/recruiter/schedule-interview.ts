import type { NextApiRequest, NextApiResponse } from "next";
import { supabase, USE_DUMMY } from "@/lib/supabaseClient";

type ScheduleInterviewResponse =
  | {
      success: true;
      interviewRequest: {
        id: string;
        candidate_id: string;
        recruiter_id: string;
        interview_type: string;
        context: string;
        preferred_date: string;
        preferred_time: string;
        start_time?: string;
        end_time?: string;
        message: string | null;
        status: string;
        created_at: string;
      };
      message: string;
    }
  | { success: false; error: string };

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ScheduleInterviewResponse>
) {
  if (req.method !== "POST") {
    res.setHeader("Allow", "POST");
    return res.status(405).json({
      success: false,
      error: "Method not allowed",
    });
  }

  try {
    // Get recruiter ID from request (should be from authenticated session)
    // For now, we'll get it from the request body or try to extract from auth
    const {
      candidateId,
      candidateName,
      candidateEmail,
      interviewType,
      context,
      preferredDate,
      preferredTime,
      startTime,
      endTime,
      message,
      applicationId,
    } = req.body;

    // Validation
    if (!candidateId) {
      return res.status(400).json({
        success: false,
        error: "Candidate ID is required",
      });
    }

    if (!interviewType || !context || !preferredDate || (!preferredTime && !startTime)) {
      return res.status(400).json({
        success: false,
        error: "All required fields must be provided",
      });
    }

    // Validate that both startTime and endTime are provided together
    if (startTime && !endTime) {
      return res.status(400).json({
        success: false,
        error: "End time is required when start time is provided",
      });
    }

    if (endTime && !startTime) {
      return res.status(400).json({
        success: false,
        error: "Start time is required when end time is provided",
      });
    }

    // Validate time range if provided
    if (startTime && endTime) {
      const timeRegex = /^\d{2}:\d{2}$/;
      if (!timeRegex.test(startTime) || !timeRegex.test(endTime)) {
        return res.status(400).json({
          success: false,
          error: "Invalid time format. Use HH:MM",
        });
      }
    }

    // Get recruiter ID from request headers or body
    // In production, this should come from the authenticated session
    const recruiterId = req.body.recruiterId || req.headers["x-recruiter-id"];

    if (!recruiterId && !USE_DUMMY) {
      // Try to get from localStorage equivalent (in real app, use session/auth)
      return res.status(401).json({
        success: false,
        error: "Recruiter authentication required",
      });
    }

    // Handle dummy mode
    if (USE_DUMMY) {
      const mockInterviewRequest = {
        id: `interview_${Date.now()}`,
      candidate_id: candidateId,
      recruiter_id: recruiterId || "recruiter_1",
      interview_type: interviewType,
      context: context,
      preferred_date: preferredDate,
      preferred_time: preferredTime || startTime,
      start_time: startTime || preferredTime,
      end_time: endTime || null,
      message: message || null,
      status: "pending",
      application_ids: applicationId ? [applicationId] : [],
      created_at: new Date().toISOString(),
    };

      return res.status(201).json({
        success: true,
        interviewRequest: mockInterviewRequest,
        message: "Interview request created successfully",
      });
    }

    // Validate date format
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    const timeRegex = /^\d{2}:\d{2}$/;

    if (!dateRegex.test(preferredDate)) {
      return res.status(400).json({
        success: false,
        error: "Invalid date format. Use YYYY-MM-DD",
      });
    }

    // Validate preferredTime if provided (for backward compatibility)
    if (preferredTime && !timeRegex.test(preferredTime)) {
      return res.status(400).json({
        success: false,
        error: "Invalid time format. Use HH:MM",
      });
    }

    // Create interview request record
    // Note: id, created_at, and updated_at are auto-generated by the database
    const interviewRequestData: any = {
      candidate_id: candidateId,
      recruiter_id: recruiterId,
      interview_type: interviewType,
      context: context.trim(),
      preferred_date: preferredDate,
      preferred_time: preferredTime || startTime, // Use startTime if preferredTime not provided
      start_time: startTime || preferredTime, // Use preferredTime if startTime not provided (backward compatibility)
      end_time: endTime || null,
      message: message?.trim() || null,
      status: "pending",
    };

    // Add application_id to array if provided
    if (applicationId) {
      interviewRequestData.application_ids = [applicationId];
    }

    const { data: interviewRequest, error: dbError } = await supabase
      .from("interview_requests")
      .insert([interviewRequestData])
      .select()
      .single();

    if (dbError) {
      console.error("Supabase interview_requests insert error:", dbError);
      return res.status(500).json({
        success: false,
        error: dbError.message || "Failed to create interview request",
      });
    }

    // Calendar events will be created when candidate accepts the interview request
    // Do NOT create calendar events here - wait for candidate acceptance

    return res.status(201).json({
      success: true,
      interviewRequest: {
        id: interviewRequest.id,
        candidate_id: interviewRequest.candidate_id,
        recruiter_id: interviewRequest.recruiter_id,
        interview_type: interviewRequest.interview_type,
        context: interviewRequest.context,
        preferred_date: interviewRequest.preferred_date,
        preferred_time: interviewRequest.preferred_time,
        start_time: interviewRequest.start_time || null,
        end_time: interviewRequest.end_time || null,
        scheduled_datetime: null, // Will be set when candidate accepts
        google_calendar_event_id: null, // Will be set when candidate accepts
        google_meet_link: null, // Will be set when candidate accepts
        message: interviewRequest.message,
        status: interviewRequest.status, // Keep as pending until candidate accepts
        created_at: interviewRequest.created_at,
      },
      message: "Interview request created successfully. Calendar events will be created when candidate accepts.",
    });
  } catch (err: any) {
    console.error("/api/recruiter/schedule-interview error:", err);
    return res.status(500).json({
      success: false,
      error: err.message || "Unknown error occurred",
    });
  }
}

